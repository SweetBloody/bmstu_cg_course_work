\chapter{Аналитический раздел}

\section{Модель представления объектов сцены}

В программе имеется набор трехмерных объектов, для которых необходимо определить модель их представления.

Сцена --- часть плоскости в форме пластинки LEGO, которая окрашена в серый цвет. Сцену можно вращать, приближать и удалять от глаз наблюдателя. Также есть возможность двигать сцену в пространстве (перемещаться по ней).

Трехмерные объекты --- набор элементов конструктора LEGO, которые пользователь может расставлять по сетке сцены и состыковывать с другими элементами конструктора. Каждый элемент представляет собой множество точек, которые соединены отрезками. Заданный набор элементов конструктора не может быть изменен. У пользователя есть возможность перемещать данные элементы по сетке сцены, добавлять и удалять их.

На рисунках \ref{img:bricks}--\ref{img:cylinder} представлены примеры доступных деталей LEGO.

\imgScale{1}{bricks}{Примеры кирпичиков}
\imgScale{1}{plates}{Примеры пластинок}
\imgScale{1}{tiles}{Примеры плиток}
\imgScale{1}{arc}{Пример арки}
\imgScale{1}{cylinder}{Пример цилиндра}
\clearpage

Источник света --- точечный объект в пространстве на некотором расстоянии от сцены, расположение которого задается с помощью значений углов по осям $X$ и $Y$ относительно наблюдателя. Лучи света распространяются от источника параллельно в сторону сцены в некотором ограниченном секторе.

Имеется три варианта отображения объекта.
\begin{itemize}[label=---]
    \item \textit{Каркасная модель} --- задается информация о вершинах и рёбрах объектов. Это простейший вид моделей, так как задается минимум информации. Однако данный вид представления объектов не всегда корректно передает форму объекта.
    \item \textit{Поверхностная модель} ---  такая модель позволяет описывать и манипулировать поверхностями и кривыми на модели. Все поверхности могут быть аппроксимированы многогранниками. Недостаток данного вида модели заключается в том, что отсутствует информация, о том, с какой стороны поверхности находится материал.
    \item \textit{Твердотельная модель} --- помимо информации о поверхности добавляется информация о том, где расположен материал. Чаще всего это делают путём указания направления внутренней нормали.
\end{itemize}

В случае конструктора лучше всего использовать поверхностную модель, так как в данном случае не важно, из какого материала сделан элемент конструктора, а каркасная модель не всегда целиком передает форму объекта.

\section{Способ задания поверхности}
Существует несколько вариантов задания поверхностной модели.
\begin{itemize}[label=---]
    \item \textit{Аналитический способ} --- заключается в том, что для получения поверхности нужно дополнительно вычислять функцию, зависящую от параметра.
    \item \textit{Полигональная сетка} --- заключается в том, что информация о модели хранится в виде совокупности вершин, ребер и граней.
\end{itemize}

Из двух представленных вариантов наиболее оптимальным является использование полигональной сетки, так как такой вариант задания поверхности позволит более быстро выполнять операции над объектами.

\section{Способ хранения полигональной модели}

Далее необходимо выбрать, как именно хранить такую сетку. Существует несколько вариантов, как это можно реализовать.

\begin{itemize}[label=---]
    \item \textit{Вершинное представление} (хранится информация о вершинах, которые в свою очередь указывают на другие вершины, с которыми они соединены).
    \item \textit{Cписок граней} (объект представляется как множество граней и вершин, любая грань состоит минимум из трёх вершин).
    \item \textit{Таблица углов} (веер треугольников).
\end{itemize}

Для хранения полигональной сетки будет использоваться список граней.

\section{Алгоритмы построения изображения}

Для того, чтобы выбрать подходящий алгоритм построения изображения, необходимо осуществить краткий обзор известных алгоритмов и осуществить выбор наиболее подходящего для решения поставленной задачи.

\subsection{Алгоритм Робертса}

Алгоритм Робертса~\cite{math_cg} представляет собой первое известное решение задачи об удалении невидимых линий. Это метод, работающий в объектном пространстве. В соответствии с алгоритмом, прежде всего из каждого тела удаляются те ребра или грани, которые перекрываются самим телом. Затем каждое из видимых ребер каждого тела сравнивается с каждым из оставшихся тел для определения того, какая его часть или части, если таковые есть, перекрываются этими телами.

Преимущества данного алгоритма в том, что математические методы, используемые в нем, просты и точны. Более поздние реализации алгоритма, например, использующие предварительную сортировку вдоль оси z, демонстрируют почти линейную зависимость от числа объектов.

Минус этого алгоритма в том, что вычислительная трудоемкость алгоритма Робертса растет теоретически, как квадрат числа объектов. Реализация оптимизированных алгоритмов весьма сложна.

Недостатки алгоритма:
\begin{itemize}[label=---]
    \item вычислительная трудоёмкость (теоретически она растёт прямо пропорционально квадрату количества объектов сцены);
    \item существуют трудности на этапе подготовки информации об объектах сцены;
    \item возможность работы только с выпуклыми объектами.
\end{itemize}

В качестве преимущества можно отметить высокую точность вычислений.

\subsection{Алгоритм Варнока}

Алгоритм Варнока~\cite{math_cg} работает в пространстве изображений. В основу алгоритма положен принцип <<разделяй и властвуй>>, состоящий в разбиении области рисунка на более мелкие подобласти (окна). Для каждой подобласти (окна) определяются связанные с ней многоугольники и те из них, видимость которых определить <<легко>>, изображаются на экране. В противном же случае разбиение повторяется, и для каждой из вновь полученных подобластей рекурсивно применяется процедура принятия решения. Предполагается, что с уменьшением размеров области ее перекрывает все меньшее и меньшее количество многоугольников. Считается, что в пределе будут получены области, содержащие не более одного многоугольника, и решение будет принято достаточно просто. Если же в процессе разбиения будут оставаться области, содержащие не один многоугольник, то следует продолжать процесс разбиения до тех пор, пока размер области не станет совпадать с одним пикселом. В этом случае для полученного пикселя необходимо вычислить глубину (значение координаты $z$) каждого многоугольника и визуализировать тот из них, у которого максимальное значение этой координаты.

\subsection{Алгоритм обратной трассировки лучей}

Данный алгоритм работает в пространстве изображения. Основная идея заключается в том, что для каждого пиксела на дисплее проводится прямой луч от наблюдателя до элемента сцены. Первое пересечение используется для определения цвета пиксела как функции пересекаемой поверхности элемента. Также проводятся вторичные лучи от точек пересечения до разных источников света для определения освещённости пиксела. Если эти лучи блокируются объектом, то данная точка находится в тени, которую отбрасывает рассматриваемый источник света. Иначе источник света влияет на освещение. Совокупность всех вторичных лучей, которые достигают источника света, определяет качество освещения, которое попадает на объект сцены. Также для более реалистичного изображения необходимо проводить лучи отражения и лучи преломления.

Преимуществом этого метода является реалистичное изображение объекта, построенное по физическим законам. А недостатком --- большая трудоемкость вычислений.

\subsection{Алгоритм, использующий z-буффер}

Данный алгоритм удаления невидимых поверхностей является одним из простейших. Этот алгоритм работает в пространстве изображения. Здесь обобщается идея о буфере кадра. Буфер кадра используется для заполнения атрибутов (интенсивности) каждого пикселя в пространстве изображения. Наряду с буфером кадра вводится z-буфер, представляющий собой специальный буфер глубины, в котором запоминаются координаты z (глубина) каждого видимого пикселя в пространстве изображения. В процессе работы глубина (значение координаты z) каждого нового пикселя, который надо занести в буфер кадра, сравнивается с глубиной того пикселя, который уже занесен в z-буфер. Если это сравнение показывает, что новый пиксель расположен ближе к наблюдателю, чем пиксел, уже находящийся в буфере кадра, то новый пиксель заносится в буфер кадра. Помимо этого производится корректировка z-буфера: в него заносится глубина нового пикселя. Если же глубина (значение координаты z) нового пикселя меньше, чем хранящегося в буфере, то никаких действий производить не надо. В сущности, алгоритм для каждой точки ($x$, $y$) находит наибольшее значение функции $Z(x, y)$.

Этот алгоритм несмотря на свою простоту позволяет удалять сложные поверхности и позволяет визуализировать пересечения таких поверхностей. Сцены могут быть произвольной сложности, а поскольку размеры изображения ограничены размером экрана дисплея, то трудоемкость алгоритма имеет линейную зависимость от числа рассматриваемых поверхностей. Элементы сцены заносятся в буфер кадра в произвольном порядке, поэтому в данном алгоритме не тратится время на выполнение сортировок, необходимых в других алгоритмах.

В рамках данной задачи нас интересует вычислительная сложность данного алгоритма.

Для каждого из $m\cdot n$ пикселей в буфере кадра размера $m\times n$ мы находим ближайший из $k$ полигонов. Исходя из данных соображений, получаем $nmk$ вычислений глубины. Таким образом временная сложность алгоритма --- O($nmk$). Вдобавок, время работы алгоритма практически не зависит от числа многоугольников, так как с увеличением их числа уменьшается размер, поэтому для каждого пикселя $k$ можно считать некоторой константой.

Преимущества алгоритма:
\begin{itemize}[label=---]
    \item относительно простая реализация;
    \item небольшая вычислительная трудоемкость;
    \item отсутствие сортировки объектов по параметру глубины, вследствие чего происходит экономия времени;
    \item возможность небольшой модификации алгоритма для работы с тенями.
\end{itemize}

Недостатки алгоритма:
\begin{itemize}[label=---]
    \item использование двух буферов, как следствие большое использование памяти;
    \item для работы с прозрачными объектами необходима модификация алгоритма.
\end{itemize}

\subsection{Выбор алгоритма построения теней}

При выборе алгоритма построения теней следует обратить внимание на простоту реализации алгоритма и время, необходимое для его написания. Если в качестве алгоритма удаления невидимых ребер и поверхностей использовать алгоритм обратной трассировки лучей, то тени уже будут построены в результате работы данного алгоритма (построение теней происходит во время выполнения алгоритма, т.к. пиксел затемняется в случае, когда испускаемый луч попадает на объект, но не попадает на источник света). Поскольку стало ясно, что алгоритм обратной трассировки использовать не следует, можно попробовать модифицировать алгоритм z-буфера путём добавления вычисления теневого буфера.

Благодаря такой модификации не потребуется писать много дополнительного кода (а лишь немного изменить уже написанный), да и модифицировать уже реализованный алгоритм удобнее, чем использовать что-то новое.

\subsection{Итоговый выбор алгоритмов}

Оценив все изложенные выше алгоритмы, я пришел к выводу, что самой подходящей комбинацией будет z-буфер и его дальнейшая модификация для построения теней. Z-буфер выбран потому, что его достаточно просто реализовать, он достаточно устойчив к входным данным, оценка сложности позволяет рассчитывать на работу этого алгоритма в реальном времени, что является одним из основных требований к данной задаче.

\section{Выбор механизма размещения объектов}

Необходимо дать пользователю возможность точно располагать объекты на сцене. Для этого используется следующий механизм:
\begin{itemize}[label=---]
    \item объекты можно добавлять только в клетки деталей LEGO, кроме деталей плиток --- на них нельзя ставить другие объекты;
    \item если пользователь указывает координату для добавления нового объекта, а на этой клетке уже стоит деталь, то новая поставится на уже существующую;
    \item нельзя удалять и перемещать элементы, к которым прикреплены другие детали.
\end{itemize}

