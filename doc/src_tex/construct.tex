\chapter{Конструкторский раздел}

\section{Алгоритм, использующий z-буфер}

Для реализации в программе был выбран алгоритм, использующий z-буфер, так как этот алгоритм способен обеспечить необходимую скорость работы.

Z-буфер является одним из простейших алгоритмов удаления невидимых поверхностей. Работает этот алгоритм в пространстве изображения. Идея z-буфера является простым обобщением идеи о буфере кадра. Буфер кадра используется для запоминания атрибутов (интенсивности) каждого пикселя в пространстве изображения, z-буфер --- это отдельный буфер глубины, используемый для запоминания координаты $z$ (глубины) каждого видимого пикселя в пространстве изображения. В процессе работы глубина или значение $z$ каждого нового пикселя, который нужно занести в буфер кадра, сравнивается с глубиной того пикселя, который уже занесен в z-буфер. Если это сравнение показывает, что новый пиксель расположен впереди пикселя, находящегося в буфере кадра, то новый пиксель заносится в этот буфер и, кроме того, производится корректировка z-буфера новым значением $z$. Если же сравнение дает противоположный результат, то никаких действий не производится. По сути, алгоритм является поиском по $x$ и $y$ наибольшего значения функции $Z(x, y)$. 

Алгоритм (рисунок \ref{img:z}):
\begin{enumerate}[label=\arabic*)]
    \item заполнение буфера кадра фоновый значением интенсивности (цвета);
    \item заполнение z-буфера минимальным значением $Z$;
    \item преобразование каждого многоугольника в растровую форму в произвольном порядке;
    \item вычисление для каждого пикселя с координатами $(x, y)$, принадлежащего многоугольнику, его глубины $Z(x, y)$;
    \item сравнение глубины $Z(x, y)$ со значением $Z_{\text{буф}}(x, y)$, которое хранится в z-буфере для пикселя с теми же координатами ($x$, $y$);
    \item запись атрибута очередного многоугольника в буфер кадра и замена $Z_{\text{буф}}(x, y)$ на значение $Z(x, y)$, если $Z(x, y)$>$Z_{\text{буф}}(x, y)$.
\end{enumerate}

\imgScale{0.65}{z}{Схема алгоритма z-буфера}
\FloatBarrier

Как уже было отмечено, главное преимущество алгоритма --- его простота. Так как габариты пространства изображения фиксированы, оценка вычис-лительной трудоемкости алгоритма не более чем линейна. Поскольку элементы сцены или картинки можно заносить в буфер кадра или в z-буфер в произвольном порядке, их не нужно предварительно сортировать по приоритету глубины. Поэтому экономится вычислительное время, затрачиваемое на сортировку по глубине.

\section{Модификация алгоритма, использующего \\z-буфер, для построения теней}

Модификация состоит из двух этапов.
\begin{enumerate}[label=\arabic*)]
    \item Строится сцена из точки, совпадающей с источником. Значения $z$ для этого ракурса хранятся в отдельном теневом z-буфере.
    \item Строится сцена из точки, в которой находится наблюдатель. При обработке каждой поверхности или многоугольника его глубина в каждом пикселе сравнивается с глубиной в z-буфере наблюдателя. Если поверхность видима, то значения $x$, $y$, $z$ из вида наблюдателя линейно преобразуются в значения $x'$, $y'$, $z'$ на виде из источника. Для того чтобы проверить, видимо ли значение $z'$ из положения источника, оно сравнивается со значением теневого z-буфера при $x'$, $y'$. Если оно видимо, то оно отображается в буфер кадра в точке $x$, $y$ без изменений. Если нет, то точка находится в тени и изображается согласно соответствующему правилу расчета интенсивности с учетом затенения, а значение в z-буфере наблюдателя заменяется на $z'$.
\end{enumerate}

На рисунках \ref{img:z_shadow1}--\ref{img:z_shadow2} представлен модифицированный алгоритм z-буфера для построения теней.

\imgScale{0.65}{z_shadow1}{Схема модифицированного алгоритма z-буфера для отображения теней (ч. 1)}
\imgScale{0.6}{z_shadow2}{Схема модифицированного алгоритма z-буфера для отображения теней (ч. 2)}
\clearpage

\section{Используемые типы и структуры данных для представления объектов}

В таблице \ref{tbl:types} представлены объекты, способ их представления в программе и типы и структуры данных для их описания.

\begin{table}[h]
\begin{center}
    % \begin{threeparttable}
    \captionsetup{justification=raggedleft}
    \caption{\label{tbl:types}Используемые типы и структуры данных для представлений объектов}
    \begin{tabular}{|l|l|l|}
        \hline
        Данные & Представление & Тип\\
        \hline
        Точка в пространстве & Координаты точки по & Список типа $double$ \\ 
                             & трем осям     &                      \\ 
        \hline
        Грань & Номера задействованных & Список типа $int$ \\ 
              & вершин                 &                   \\ 
        \hline
        Полигональная        & Набор задействованных & Списки типа \\ 
        модель               & вершин и граней       & $Vertex$ (вершина) \\
                             &                       & и $Facet$ (грань) \\ 

        \hline
        Источник света & Углы по двум осям & Тип $int$ \\ 
        \hline
    \end{tabular}
    % \end{threeparttable}
\end{center}
\end{table}

\section{Описание используемых классов}

В результате разработки программы были реализованы классы, представленные ниже.
\begin{itemize}[label=---]
    \item $Dot3D$ --- класс точки в пространстве, который хранит ее кординаты.
    
    \item $Vertex$ --- класс для описания вершины. Хранит координаты самой вершины и список граней, в которых она находится.
    
    \item $Facet$ --- класс задающий грань с помощью списка ее вершин.
    
    \item $PolygonModel$ --- класс полигональной модели, хранящий в себе списки вершин и граней модели, а также информацию о размерах модели, ее типе и положении в сетке сцены.
    
    \item $Light$ --- класс, описывающий источник света и хранящий информацию о положении источника, а также информацию о теневой карте.
    
    \item $SceneInf$ --- класс, хранящий информацию о текущем состоянии сцены: размеры платформы, список добавленных моделей (деталей LEGO) и источников света, а также информацию о <<заполненности>> по высоте каждой клетки платформы.
    
    \item $AddBrick$, $AddPlate$, $AddTile$, $AddArc$, $AddCylinder$, $AddLight$ --- классы интерфейсов добавления соответствующих объектов на сцену.
    
    \item $ObjectMove$, $ObjectChange$, $ObjectDelete$ --- классы интерфейсов перемещения и удаления объектов.
    
    \item $Drawer$ --- класс, который необходим для отрисовки сцены, он хранит буферы глубины и кадра.

    \item $Facade$ --- класс для связи взаимодействия пользователя с программой. Хранит объекты класса $SceneInf$ и $Drawer$.
    
\end{itemize}

\section{Структура программного комплекса}

Программа должна обеспечить выполнение следующих функций:
\begin{itemize}[label=---]
    \item создание платформы для построения конструкций заданного размера;
    \item добавление на сцену деталей LEGO заданного размера (если для данной детали предусмотрен ввод длины и ширины);
    \item удаление и перемещение деталей LEGO, на которых не стоят другие элементы;
    \item перемещение, поворот и масштабирование платформы с находящимися на ней деталями;
    \item добавление и удаление источников света.
\end{itemize}

\clearpage
Таким образом в интерфейсе должны присутствовать следующие разделы.
\begin{enumerate}[label=\arabic*)]
    \item Модуль для отрисовки сцены:
        \begin{itemize}[label=---]
            \item виджет отображения сцены
            \item кнопка добавления сцены;
            \item окно ввода размеров сцены;
            \item кнопка <<вид сверху>>.
        \end{itemize}
    \item Модуль для работы со сценой:
        \begin{itemize}[label=---]
            \item кнопки перемещения;
            \item кнопки поворота;
            \item кнопки масштабирования;
        \end{itemize}
    \item Модуль для работы с объектами сцены:
        \begin{itemize}[label=---]
            \item список доступных объектов (детали LEGO и источник света);
            \item кнопки добавления, удаления и перемещения;
            \item окна ввода координат и размеров объектов.
        \end{itemize}
\end{enumerate}